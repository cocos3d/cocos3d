<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Cocos3D: Cocos3D API reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-cocos3d.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">
	   <a href="http://cocos3d.org"><img src="http://cocos3d.org/images/cocos3d-Banner-55h.png" /></a>
	   <span id="projectnumber">v2.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Instance Methods</a> &#124;
<a href="#pub-static-methods">Class Methods</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_c_c3_shader_context-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CC3ShaderContext Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#import &lt;CC3ShaderContext.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3ShaderContext:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_shader_context__inherit__graph.png" border="0" usemap="#_c_c3_shader_context_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Instance Methods</h2></td></tr>
<tr class="memitem:a01d5d0248a3d0c232af3459ede64f75f"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_context.html#a01d5d0248a3d0c232af3459ede64f75f">fullDescription</a></td></tr>
<tr class="separator:a01d5d0248a3d0c232af3459ede64f75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377831469642bcf0cbfaac0617434ba1"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_context.html#a377831469642bcf0cbfaac0617434ba1">populateFrom:</a></td></tr>
<tr class="separator:a377831469642bcf0cbfaac0617434ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac529b080ce2926d0b624ca20cb08d739"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_context.html#ac529b080ce2926d0b624ca20cb08d739">populateUniform:withVisitor:</a></td></tr>
<tr class="separator:ac529b080ce2926d0b624ca20cb08d739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d5dc1500548bd7265000668be86fc3"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_context.html#a19d5dc1500548bd7265000668be86fc3">removeAllUniformOverrides</a></td></tr>
<tr class="separator:a19d5dc1500548bd7265000668be86fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5dc6802f708833a7272b10e8bd46483"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_context.html#ac5dc6802f708833a7272b10e8bd46483">removeUniformOverride:</a></td></tr>
<tr class="separator:ac5dc6802f708833a7272b10e8bd46483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af26aebca764ea8a66592ae0e4b2a9d"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_context.html#a0af26aebca764ea8a66592ae0e4b2a9d">uniformOverrideAtLocation:</a></td></tr>
<tr class="separator:a0af26aebca764ea8a66592ae0e4b2a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3891c4fdb09001b932cc3a096fc2bdcd"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_context.html#a3891c4fdb09001b932cc3a096fc2bdcd">uniformOverrideForSemantic:</a></td></tr>
<tr class="separator:a3891c4fdb09001b932cc3a096fc2bdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2a94f6b5ddca69e61fba3f30afcb0f"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_context.html#aaf2a94f6b5ddca69e61fba3f30afcb0f">uniformOverrideForSemantic:at:</a></td></tr>
<tr class="separator:aaf2a94f6b5ddca69e61fba3f30afcb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccfec27da2dc3e1ac2eae8e6d94e608"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_context.html#acccfec27da2dc3e1ac2eae8e6d94e608">uniformOverrideNamed:</a></td></tr>
<tr class="separator:acccfec27da2dc3e1ac2eae8e6d94e608"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Class Methods</h2></td></tr>
<tr class="memitem:a32c81f54fec26953e96270bddbb8bc68"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_context.html#a32c81f54fec26953e96270bddbb8bc68">context</a></td></tr>
<tr class="separator:a32c81f54fec26953e96270bddbb8bc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a7215158bf0b4df86f0156297e4b1ab63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_shader_program.html">CC3ShaderProgram</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_context.html#a7215158bf0b4df86f0156297e4b1ab63">program</a></td></tr>
<tr class="separator:a7215158bf0b4df86f0156297e4b1ab63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ac390d2e5910429fe4a6c7e5ba09ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_shader_program.html">CC3ShaderProgram</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_context.html#af6ac390d2e5910429fe4a6c7e5ba09ef">pureColorProgram</a></td></tr>
<tr class="separator:af6ac390d2e5910429fe4a6c7e5ba09ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b6ee5c865080c8033ea223bf490198"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_context.html#a49b6ee5c865080c8033ea223bf490198">shouldEnforceCustomOverrides</a></td></tr>
<tr class="separator:a49b6ee5c865080c8033ea223bf490198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1d5a29b748c0b95d0b15c3b27923c5"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_context.html#aae1d5a29b748c0b95d0b15c3b27923c5">shouldEnforceVertexAttributes</a></td></tr>
<tr class="separator:aae1d5a29b748c0b95d0b15c3b27923c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="interface_c_c3_shader_context.html" title="CC3ShaderContext holds a CC3ShaderProgram for a particular use, such as a by a particular node...">CC3ShaderContext</a> holds a <a class="el" href="interface_c_c3_shader_program.html" title="CC3ShaderProgram represents an OpenGL shader program, containing one vertex shader and one fragment s...">CC3ShaderProgram</a> for a particular use, such as a by a particular node. </p>
<p>A single <a class="el" href="interface_c_c3_shader_program.html" title="CC3ShaderProgram represents an OpenGL shader program, containing one vertex shader and one fragment s...">CC3ShaderProgram</a> object can be used by many nodes and other contexts. The <a class="el" href="interface_c_c3_shader_context.html" title="CC3ShaderContext holds a CC3ShaderProgram for a particular use, such as a by a particular node...">CC3ShaderContext</a> contains state and behaviour specific to a particular use of the program, including providing storage for local values for certain customized program variables in use by the node.</p>
<p>A particular program may make use of many uniforms. In most, or many, cases, the uniform will have a semantic defined, and the content of the uniform will automatically be extracted from the environment, including from the content of the node itself. For uniforms without a defined semantic, the content of the uniform must be set by accessing it through this program context.</p>
<p>When retrieving a uniform variable through this program context, be aware that the content value of any uniform variable with a defined semantic is derived automatically from the environment, and cannot be retrieved or set directly. </p>
</div><h2 class="groupheader">Method Documentation</h2>
<a class="anchor" id="a32c81f54fec26953e96270bddbb8bc68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) context </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes an instance without specifying a program during init. </p>
<p>The program can be set later using the program property. </p>

</div>
</div>
<a class="anchor" id="a01d5d0248a3d0c232af3459ede64f75f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString*) fullDescription </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a detailed description of this instance, including a description of each uniform and attribute. </p>

</div>
</div>
<a class="anchor" id="a377831469642bcf0cbfaac0617434ba1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateFrom: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_shader_context.html">CC3ShaderContext</a> *)&#160;</td>
          <td class="paramname"><em>another</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template method that populates this instance from the specified other instance. </p>
<p>This method is invoked automatically during object copying via the copy or copyWithZone: method. In most situations, the application should use the copy method, and should never need to invoke this method directly.</p>
<p>Subclasses that add additional instance state (instance variables) should extend copying by overriding this method to copy that additional state. Superclass that override this method should be sure to invoke the superclass implementation to ensure that superclass state is copied as well. </p>

</div>
</div>
<a class="anchor" id="ac529b080ce2926d0b624ca20cb08d739"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) populateUniform: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a> *)&#160;</td>
          <td class="paramname"><em>uniform</em></td>
        </tr>
        <tr>
          <td class="paramkey">withVisitor:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *)&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This callback method is invoked from the bindWithVisitor: method of the associated GL program. </p>
<p>If this context includes an override uniform that matches the specified program uniform, the content of the specified uniform is updated from the content held in the matching override uniform in this context. If no matching override uniform exists within this context, nothing happens.</p>
<p>Returns whether the specified uniform was updated. If the uniform was not updated, and the semantic of the uniform is unknown, the value returned by this method depends on the value of the shouldEnforceCustomOverrides property. If this context does not update a uniform whose semantic is unknown, and the shouldEnforceCustomOverrides property is set to YES (the default), this method will return NO, indicating that the uniform is unresolvable, and likely in error. This will typically result in an assertion error being raised, to indicate that the application should set the override. However, if the shouldEnforceCustomOverrides property is set to NO, this method will return YES under the same conditions, which will cause the shader program to use the current value of the uniform variable, which might be an initial default identity value, or might be a value set by another mesh node that is using the same shader program.</p>
<p>This context can keep track of content to be used for any uniform in the associated program. This contextual content can be used for uniforms whose content cannot be extracted from a standard semantics, or can be used to override the value that would be extracted from the environment for the semantic of the uniform. To create an override uniform, access it via one of the uniformOverride... methods.</p>
<p>If the specified uniform is from a program that is not the same as the program controlled by this context, the override is not populated, and this method returns NO. This can occur when drawing with a different program, such as during node picking. </p>

</div>
</div>
<a class="anchor" id="a19d5dc1500548bd7265000668be86fc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeAllUniformOverrides </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all current uniform overrides. </p>

</div>
</div>
<a class="anchor" id="ac5dc6802f708833a7272b10e8bd46483"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeUniformOverride: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a> *)&#160;</td>
          <td class="paramname"><em>uniform</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified unifrom override from the uniforms being overridden by this context. </p>
<p>The specified uniform must be have previously been retrieved by one of the uniformOverride... method of this context.</p>
<p>Attempting to override a uniform whose semantic property is set to kCC3SemanticNone will raise an assertion error, since doing so would leave the program uniform with no way of being populated within the program, which would result in a program execution error. </p>

</div>
</div>
<a class="anchor" id="a0af26aebca764ea8a66592ae0e4b2a9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a>*) uniformOverrideAtLocation: </td>
          <td></td>
          <td class="paramtype">(GLint)&#160;</td>
          <td class="paramname"><em>uniformLocation</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the uniform at the specified program location, or nil if no uniform is at the specified location. </p>
<p>The specified uniformLocation value is the location assigned to the uniform by the GL engine. This value may be different between the shader program in the program property of this context and the shader program in the pureColorProgram property of this context. The specified uniformLocation must be the location of the uniform in the shader program in the program property of this context.</p>
<p>Invoking this method more than once will return the same uniform override, and the content of the returned uniform is sticky, so the application does not need to keep track of the returned uniform, and only needs to make changes to the content of this uniform when it wants to change that content. Specifically, the application does not need to access, or set the content of, the uniform during each frame update or render cycle. Once set, the content of this uniform will automatically be applied to the GL engine for this context (typically a <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a>), on each render cycle.</p>
<p>By invoking this method, an override uniform is created, and the application takes responsibility for populating the value of this overriden uniform, by invoking any of the set... methods on the returned uniform. If this method has been used to override a program uniform whose content can be extracted semantically from the environment, you can remove this override by invoking the removeUniformOverride: method with the uniform returned by this method.</p>
<p>If the program has no uniform at the specified location, this method does nothing and returns nil. </p>

</div>
</div>
<a class="anchor" id="a3891c4fdb09001b932cc3a096fc2bdcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a>*) uniformOverrideForSemantic: </td>
          <td></td>
          <td class="paramtype">(GLenum)&#160;</td>
          <td class="paramname"><em>semantic</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an override for the program uniform with the specified semantic and semantic index zero. </p>
<p>This is a convenience method that invokes the uniformOverrideForSemantic:at: method, passing zero for the semanticIndex argument. See the description of that method for more info. </p>

</div>
</div>
<a class="anchor" id="aaf2a94f6b5ddca69e61fba3f30afcb0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a>*) <a class="el" href="interface_c_c3_shader_context.html#a3891c4fdb09001b932cc3a096fc2bdcd">uniformOverrideForSemantic:</a> </td>
          <td></td>
          <td class="paramtype">(GLenum)&#160;</td>
          <td class="paramname"><em>semantic</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>semanticIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an override for the program uniform with the specified semantic and semantic index. </p>
<p>The semantic describes what type of content the uniform is tracking in the GLSL shader code. It is usually one of the values from the CC3Semantic, although the application can also define values outside the range of this enumeration, if needed. The semantic index is used for semantics that may appear more than once in the scene and in the shader code.</p>
<p>For example, the shader might support several lights. The semantic kCC3SemanticLightPositionEyeSpace indicates that the uniform is tracking the position of a light in eye space, and the semantic index then represents the index of a particular light. The index is zero-based.</p>
<p>The application can use this method to set the value of a uniform directly, either to populate a program uniform whose content cannot be extracted semantically from the environment, or to override the value that would be extracted, with an application-specific value.</p>
<p>Invoking this method more than once will return the same uniform override, and the content of the returned uniform is sticky, so the application does not need to keep track of the returned uniform, and only needs to make changes to the content of this uniform when it wants to change that content. Specifically, the application does not need to access, or set the content of, the uniform during each frame update or render cycle. Once set, the content of this uniform will automatically be applied to the GL engine for this context (typically a <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a>), on each render cycle.</p>
<p>By invoking this method, an override uniform is created, and the application takes responsibility for populating the value of this overriden uniform, by invoking any of the set... methods on the returned uniform. If this method has been used to override a program uniform whose content can be extracted semantically from the environment, you can remove this override by invoking the removeUniformOverride: method with the uniform returned by this method.</p>
<p>If the program has no uniform that matches the specified semantic and semantic index, this method does nothing and returns nil. </p>

</div>
</div>
<a class="anchor" id="acccfec27da2dc3e1ac2eae8e6d94e608"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a>*) uniformOverrideNamed: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>name</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an override for the program uniform with the specified name. </p>
<p>The application can use this method to set the value of a uniform directly, either to populate a program uniform whose content cannot be extracted semantically from the environment, or to override the value that would be extracted, with an application-specific value.</p>
<p>Invoking this method more than once will return the same uniform override, and the content of the returned uniform is sticky, so the application does not need to keep track of the returned uniform, and only needs to make changes to the content of this uniform when it wants to change that content. Specifically, the application does not need to access, or set the content of, the uniform during each frame update or render cycle. Once set, the content of this uniform will automatically be applied to the GL engine for this context (typically a <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a>), on each render cycle.</p>
<p>By invoking this method, an override uniform is created, and the application takes responsibility for populating the value of this overriden uniform, by invoking any of the set... methods on the returned uniform. If this method has been used to override a program uniform whose content can be extracted semantically from the environment, you can remove this override by invoking the removeUniformOverride: method with the uniform returned by this method.</p>
<p>If the program has no uniform with the specified name, this method does nothing and returns nil. </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a7215158bf0b4df86f0156297e4b1ab63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_shader_program.html">CC3ShaderProgram</a>*) program</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the program for which this instance is providing a context. </p>
<p>Setting this property will redefine the variables that can be retrieved via the uniform... methods, and will clear the pureColorProgram so that a new pureColorProgram will be matched to the new program on next access. </p>

</div>
</div>
<a class="anchor" id="af6ac390d2e5910429fe4a6c7e5ba09ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_shader_program.html">CC3ShaderProgram</a>*) pureColorProgram</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the program to use to render this node in a pure color, such as used when rendering the node during paint-basede node picking as a result of a touch event. </p>
<p>If this property is not set directly, it will be set automatically on first access, by retrieving the picking program that matches the shader program in the program property. This will usually be a program that has the same vertex shader as the shader program in the program property, but has a fragment shader that paints in a single color. By using the same vertex shader, the vertices are guaranteed to be rendered in the same locations. </p>

</div>
</div>
<a class="anchor" id="a49b6ee5c865080c8033ea223bf490198"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldEnforceCustomOverrides</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this context should ensure that all uniforms with an unknown semantic must have a uniform override established. </p>
<p>Uniform variables whose semantic is unknown cannot be resolved automatically from scene content, and generally require that a uniform override be established in this context, in order for a meaningful uniform value to be passed to the shader program.</p>
<p>If the value of this property is YES, when a uniform of unknown semantic is processed by the populateUniform:withVisitor: method, and a uniform override has not been established in this context for that uniform by the application, the populateUniform:withVisitor: method will return NO. This will generally result in an assertion error being raised.</p>
<p>If the value of this property is NO, the populateUniform:withVisitor: method will return YES under the same conditions. This will cause the uniform to use its current value, which might be an initial default identity value, or might be a value set by another mesh node that is using the same shader program.</p>
<p>The initial value of this property is YES, indicating that the application must provide an override for any uniform whose semantic is unknown. In most cases, you should leave the value of this property set to YES, to avoid unpredictable behaviour. However, there might be some occasions, particularly when the value is never set by any mesh node, and the default identity value is acceptable. </p>

</div>
</div>
<a class="anchor" id="aae1d5a29b748c0b95d0b15c3b27923c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldEnforceVertexAttributes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this context should ensure that all vertex attributes have a valid semantic. </p>
<p>If the value of this property is YES, when a vertex attribute variable of unknown semantic is processed, an assertion error will be raised.</p>
<p>If the value of this property is NO, no assertion error will be raised, and the attribute will remain unpopulated. Under these conditions, the shader may render the node in an unexpected manner.</p>
<p>The initial value of this property is YES, indicating that the application must ensure that all vertex attributes must have a valid, resolvable semantic. You may set the value of this property to NO if your shader has been designed to handle the case where the vertex attribute is not set. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_c_c3_shader_context_8h.html">CC3ShaderContext.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<address class="footer">
<p class="footer"/>Â© 2010 - 2014 The Brenwill Workshop Ltd.</p>
</address>
</body>
</html>
